 
Бинарный поиск - это алг-им; на входе получает отсортированный список эл-ов . Если эл-нт, который мы ищем присутствует в списке, то бинарный поиск возвращает ту позицию, в которой он был найден. В противном случае бин поиск вернет null.

Пример: 
Играем в игру чел загадал числу нам нужно угодать за меньшее кол-во попыток.
У нас 2 варианта:
	1) тупой мы просто пребераем от 1 до 100. Если чел заказал 99, то нам понадобится 99 попыток.
	2) эффективный способ(бинарный). Мы начинаем поиск с середины(50) и так сбрасываем по половине те. мы говорим 50 он больше мы 75 он меньше мы 63  он много 57 и мы попали и вместо 99 шагов мы сделали 4 шага

Итак бин поиск выполняется за log2n шаго, в то время как простой поиск за n шагов.

Памятка!!! 
Логарифм - операция, обратная возведению в степень
Пример.
log10 100 =2 тк 10в степени 2 =100 или log2 8 = 3 тк 2в степени 3 = 8.

Примечание:
Бин поиск работает только с отсортированным списком .

Пример на Python:
def binary_search(list, item):
    low = 0
    high = len(list)-1
  
    while low <= high:
        mid = int((low + high)/2)
        guess = list[mid]
        
        if guess == item:
            return mid
        if guess > item:
            high = mid - 1
        else:
            low = mid + 1

    return None

my_list = [1,  3,  5,  7, 9]

print (binary_search(my_list,3))

print (binary_search(my_list,-1))

O большое:

Время выполнения алгоритмов растет с разной скоростью 

Боб пишет алгоритм поиска для NASA. Его алгоритм заработает, когда ракета будет подлетать к луне, и поможет выполнить точку позади.

Боб пытается выбрать между  простым и бинарным поиском. Его алг-м должен работать быстро и правильно. С 1ой стороны бин поиск работает быстрее с другой, простой поиск и  без ошибок. Боб не хочет совершить ошибку при посадке ракеты. И тогда для пущей уверенности Боб  решает измерить время выполнения обоих алг-ов для списка из 100 эл-ов.

Допустим проверка 1 эл-та занимает 1 мс. => обычный поиск  займет 100мс. С другой стороны бин поиск  займет 7 мс. 
Время выполнения так же растет с разной скоростью.

Big O  описывает, насколько быстро работает алг-м. Предположим имеется список размера n. Простой поиск  должен проверить каждый эл-нт, поэтому придется выполнить n операций. Врем выполнения "О-большое" не сообщает скорость в секундах, а позволяет сравнить количество операций. Оно указывает, насколько быстро возрастает время выполнения алгоритма.

О большое записывается так O- big O ; (n)- кол во операций.

Наглядное представление "О большое":
СТР 32


O большое описывает худший возможный случай: т.е  мы утверждаем что придется смотреть каждый эл-нт списка. 

Типичные примеры биг О :
O(logn) - бинарный поиск
O(n) - простой поиск
O(n * logn) - Эффективные алг сортировки (быстрая сортировка)
O(n ** 2) - медленные алгоритмы(сортировка выбором)
O(n!) очень медленные алг

Скорость алг измеряется не в сек, а а втемпе роста  кол- ва операций.

По сути, формула описывает насколько быстро возрастает время выполнения алг с увеличением размера вход данных

Время выполнения алг выражается как О большое

Время выполнения O(logn) быстрее O(n), а с увеличением размера списка, в котором ищется значение, оно становится намного быстрее.

Шпаргалка:

Бин поиск работает намного быстрее простого.

Время выполнения O(logn) быстрее O(n), а с увеличением размера списка, в котором ищется значение, оно становиться намного быстрее.

Скорость алгоритма не измеряется в секундах.

Время выполнения алг описывается ростом кол -ва операций.

Время выполнения алг выражается как О- большое.

Сортировка выбором.
Как работает память?

Пример: 
Раскладываем вещи в шкаф в каждый ящик, каждый ящик имеет адрес, так же наша память ячейки с адресами. 
Те если нам нужно сохранить отдельное значение, мы запрашиваем у компа место в памяти, а он выдает адрес для сохранения выражения. Если нам нужно сохранить более 1 выражения это можно сделать 2мя способами: используя массив или список.

Массивы и связанные списки:

При использовании массива все задачи хранятся в памяти непрерывно(то есть рядом друг с другом).  В массиве проблема, нужно выделять место заранее т.е даже если у нас только 3 яч занято то запросить нужно от 3, а лучше 10. Эту проблему решает Связанный список.

Связанный список.

При использовании связанного списка эл-ты могут размещаться где угодно в памяти.

В каждом эл-те хранится адрес следующего эл- та списка. Таким образом , набор произвольных адресов памяти объединяется в цепочку.

все как в игре найти клад вы приходите по 1 адресу, там написано след эл-нт находится по адресу... . Добавить новый эл-нт проще просто разместив его по любому адресу памяти и сохраните этот адрес в пред эл - те.

Массивы - прекрасно подходят для чтения эл-ов в произвольных поз-ях, потому что обращение  к люб эл-ту в массиве происходит мгновенно.

		списки	массивы 
чтение          O(n)        O(1)
вставка         O(1)        O(n)

O(n) = линейное время  
O(1) = постоянное время

Вставка в середину списка.

Предположим мы решили, что список задач должен больше напоминать календарь. Прежде данные добавлялись только в конец списка, а теперь они должны добавляться в порядке их выполнения.

Для данной задачи лучше подходят списки. Тк там просто изменить адрес пред эл.

Удаление.

Также список будет лучше т.к просто изменить адрес.

Сортировка выбором.

Пример:

У нас на компе записана музыка и для каждого исполнителя хранится счетчик воспроизведений. Мы хотим отсортировать список по убыванию чтобы самые любимые музыканты стояли на 1х местах. Как это сделать.

одно из возм решений это искать в одном списке самый прослушиваемого исп  и добавлять его в новый список. Но это займет O(n) времени.

Шпаргалка
Память пк напоминает огромный шкаф с ящиками.
Если нам понадобиться сохранить набор эл-ов, воспользуйтесь массивом или списком.
В массиве все эл-ты хранятся в памяти рядом друг с другом.
В списке эл-ты распреде-ются в произ-ых местах памяти, при этом в одном эл-те хранится адрес след эл-та.
Массивы обесп-ют быстрое чтение. Списки обес-ют быструю вставку и удаление.

Рекурсия:

Рекурсией называется вызов функцией самой себя.

def look_for_key(box):
	for item in box:
			if item.is_a_box():
				look_for_key(item)  <- Рекурсия!
			elif item.is_a_key():
				print "found the key"

Базовый и рекурсивный случай:

пример нам нужно написать функцию обратного отсчета.
Рекурсией это будет выглядеть так:

def countdown(i):
	print i
countdown(i - 1)

И тут возникает проблема: эта функция выполняется бесконечно.

Вот почему  каждая рекурсия имеет базовый и рекурсивный случай.
В рекурсивном случае она вызывает сама себя. А в базовом она себя не вызывает, что бы предотвратить зацикливание.

Добавим базовый случай в countdown:

def countdown(i):
	print i
	if i<= 1:
		return
	else:
		countdown(i-1)

Стек вызовов:

Пример мы устраиваем BBQ. Мы составляем список задач на листиках: Мы имеем всего 2 задачи вставка и выведения из списка.

Посмотрим ка работает список задач: 

задача извлекается из стопки -> на листке задача ->
Стек - простая структура данных.
Во внутренней работе пк используется стек, называемый стеком вызовов.
Давайте посмотрим, как он работает. 
Предположим, имеется функция:
def greet(name):
	print "hekko," + name+ "!"
def bye():
	print "ok Bye!"

Что происходит при вызове функции:
Предположим, в программе используется вызов greet("maggie). Сначала наш пк выделяет блок памяти для вызова этой функции. Затем эта память используется . Переменной name присваивается значение "maggie"; оно должно быть сохранено в памяти.

Каждый раз, когда мы вызываем функцию , пк сохраняет в памяти значения всех пер-нных для этого вызова. Далее выводится приветствие Hallo, maggie!, после чего следует 2 вызов greet2("maggie"). И снова пк выделяет блок памяти для вызова функции.

Наш пк объединяет эти блоки в стек. Второй блок создается над первым. Мы вводим сообщение how are  you, maggie?, после чего возвращаете управление из вызова функции. Когда это происходит, блок на вершине стека извлекается из него.

Теперь  верхний блок в стеке относится к функции greet; это означает, что мы вернулись к функции greet. При вызове функции greet2 функция greet еще не была завершена. Здесь то и скрывается истинный смысл этого раздела: когда мы вызываем функцию из другой функции, вызывающая функция приостанавливается в частично завершенном состоянии. Все значения переменных этой функции остаются в памяти. А когда выполнение функции greet2 будет завершено, мы вернемся к функции greet и продолжите ее выполнение с того места, где оно прервалось. Сначала выводится сообщение getting ready to say bye, после чего вызывается функция bye.

Блок для этой функции добавляется на вершину стека. Далее выводится сообщение ok Bye с выходом из вызова функции.

Управление снова возвращается функции greet. Делать больше нечего, так что управление возвращается и из функции greet. Этот стек, в котором сохранялись переменные разных функций, называется стеком вызовов. 

Стек вызовов с рекурсией:
 Рек функции так же используют стек вызовов.

Шпаргалка:

Когда функция вызывает саму себя, это называется рекурсией.

В каждой рек функции должно быть 2 случая, базовый и рекурсивный.

Стек поддерживает 2 опции: занесение и извлечение эл-ов.

Все вызовы функций сохр-ся в стеке вызовов.

Если стек вызовов станет очень большим, он займет слишком много памяти.

Быстрая сортировка.

Совет: 
Когда мы пишем рекурсивную функцию, в который задействован массив, базовым случаем часто оказывается пустой массив или массив из 1 элемента. Если мы не знаем, с чего начет то лучше начать с этого.


Разделяй и влавствуй 
Шпора:
 Эта стратегия основана на разбиении задачи на уменьшающееся фрагменты. Если мы используем эту стратегию со списком, то базовым случаем является пустой массив или массив из 1 эл-та

Если реализуем алг-м быстрой сортировки, вберем в качестве опорного случайный эл-нт. Среднее время выполнения быстрой сортировки составляет O(nlogn) 

Константы в биг О иногда могут иметь значение. Именно по этой  причине быстрая сортировка быстрее сортировки слиянием

Хеш таблицы:

Она должна быть последовательной. 

Разными словам должны соответствовать разные числа.

Шпаргалка

Хеши хорошо подходят для 

моделирования отношений между объектов,

устранение дубликатов,

кеширования.

Для создания двухсторонней очереди(дека) используется функция deque.

Поиск в ширину:

Шпаргалка 

Поиск в ширину позволяет определить, существует ли путь из А в В.

Если путь существует, то поиск в ширину находит кратчайший путь.

Если в нашей задаче требуется найти кратчайшее Х, попробуем смоделировать задачу графом и воспользуемся поиском в ширину.

В ненаправленном графе есть стрелки, а отношения действуют в направлении стрелки.

Очереди относятся к FIFO(первым вошел первым вышел)

Стек относится к LIFO(последним пришел первым вышел)

Список поиска, всегда должен быть оформлен как очередь.

Алгоритм Дейкстры 

Шпора 

Поиск в ширину вычисляет кратчайший путь в невзвешенном графе.

Алгоритм Дейкстры вычисляет кратчайший путь в взвешенном графе.

Алгоритм Дейкстры работает только в том случае, если все веса положительны, в ином случае используем алг Беллмана-Форда https://habr.com/ru/companies/otus/articles/484382/
\
Жадные алгоритмс 
\
Шпаргалка

Жад алг стремятся к локальной оптимизации в расчете на то, что в  итоге будет достигнут глобальный оптиум.

У NP полных задач нету быстрых решений.

NP сложные задачи решать приближенным алгоритмом.

Динамическое программирование

Шпора
Дин прог  применяется при оптимизации некой характеристики.

Дин прог раб только в ситуациях в которых задача может быть разбита на автономные подзадачи.

В каждом решении из обл дин прог строится таблица.

Знач ячеек табл обычно соответсвуют оптимиз хар-ке

Каждая ячейка представляет подзадачу, поэтому мы должны подумать о том, как разбить задачку на подзадачи.

Не существует единой формулы для вычисленя решений методом динамического програмирования.

Алгоритм k ближ соседей 
Шпора 

Алгоритм K ближ соседей применяется доя классификации и регрессии. В  нем используется проверка k ближ соседей.

Классификация = распределение по категориям.

Регрессия = прогнозирование результата(например числа)

"Извлечением признаков" называется преобразованием эл-та (например, фрукта или пользователя) в список чисел, которые могут использоваться для сравнения.

Качественный выбор признаков - важная часть успешного алгоритма k  ближайших соседей.

