
Бинарный поиск - это алг-им; на входе получает отсортированный список эл-ов . Если эл-нт, который мы ищем присутствует в списке, то бинарный поиск возвращает ту позицию, в которой он был найден. В противном случае бин поиск вернет null.

Пример: 
Играем в игру чел загадал числу нам нужно угодать за меньшее кол-во попыток.
У нас 2 варианта:
	1) тупой мы просто пребераем от 1 до 100. Если чел заказал 99, то нам понадобится 99 попыток.
	2) эффективный способ(бинарный). Мы начинаем поиск с середины(50) и так сбрасываем по половине те. мы говорим 50 он больше мы 75 он меньше мы 63  он много 57 и мы попали и вместо 99 шагов мы сделали 4 шага

Итак бин поиск выполняется за log2n шаго, в то время как простой поиск за n шагов.

Памятка!!! 
Логарифм - операция, обратная возведению в степень
Пример.
log10 100 =2 тк 10в степени 2 =100 или log2 8 = 3 тк 2в степени 3 = 8.

Примечание:
Бин поиск работает только с отсортированным списком .

Пример на Python:
def binary_search(list, item):
    low = 0
    high = len(list)-1
  
    while low <= high:
        mid = int((low + high)/2)
        guess = list[mid]
        
        if guess == item:
            return mid
        if guess > item:
            high = mid - 1
        else:
            low = mid + 1

    return None

my_list = [1,  3,  5,  7, 9]

print (binary_search(my_list,3))

print (binary_search(my_list,-1))

O большое:

Время выполнения алгоритмов растет с разной скоростью 

Боб пишет алгоритм поиска для NASA. Его алгоритм заработает, когда ракета будет подлетать к луне, и поможет выполнить точку позади.

Боб пытается выбрать между  простым и бинарным поиском. Его алг-м должен работать быстро и правильно. С 1ой стороны бин поиск работает быстрее с другой, простой поиск и  без ошибок. Боб не хочет совершить ошибку при посадке ракеты. И тогда для пущей уверенности Боб  решает измерить время выполнения обоих алг-ов для списка из 100 эл-ов.

Допустим проверка 1 эл-та занимает 1 мс. => обычный поиск  займет 100мс. С другой стороны бин поиск  займет 7 мс. 
Время выполнения так же растет с разной скоростью.

Big O  описывает, насколько быстро работает алг-м. Предположим имеется список размера n. Простой поиск  должен проверить каждый эл-нт, поэтому придется выполнить n операций. Врем выполнения "О-большое" не сообщает скорость в секундах, а позволяет сравнить количество операций. Оно указывает, насколько быстро возрастает время выполнения алгоритма.

О большое записывается так O- big O ; (n)- кол во операций.

Наглядное представление "О большое":
СТР 32


O большое описывает худший возможный случай: т.е  мы утверждаем что придется смотреть каждый эл-нт списка. 

Типичные примеры биг О :
O(logn) - бинарный поиск
O(n) - простой поиск
O(n * logn) - Эффективные алг сортировки (быстрая сортировка)
O(n ** 2) - медленные алгоритмы(сортировка выбором)
O(n!) очень медленные алг

Скорость алг измеряется не в сек, а а втемпе роста  кол- ва операций.

По сути, формула описывает насколько быстро возрастает время выполнения алг с увеличением размера вход данных

Время выполнения алг выражается как О большое

Время выполнения O(logn) быстрее O(n), а с увеличением размера списка, в котором ищется значение, оно становится намного быстрее.

