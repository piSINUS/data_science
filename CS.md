 Глава 6 Базы данных :
Глубинный анализ данных  - процесс извлечения информации из имеющихся массивов информации.

 
Реляционная модель.
Помогает избежать дублирования информации  и противоречий.
Большой недостаток  Рел модели - все записи  - строки , и СУБд не примет новою строку, если та нарушает схему таблицы.

Отношения.

Чтобы избежать трудностей повторений, реляционная модель разбивает данные на разные таблицы. Например, разделим наши данные о счетах-фактурах на две таблицы - "Заказы" и "Клиенты"- и сделаем так, чтобы каждая строка в первой таблице ссылалась на строку во второй ( стр 143)
За счет связывания между собой данных из различных таблиц один клиент может быть частью многих заказов, а дублирования при этом не случиться. Для поддержки связей каждая таблица имеет специальное идентификационное поле, или ID. Мы используем значения Id для ссылки на конкретную строку в таблице. Эти значения должны быть уникальными. Поле Id таблицы также называется её  первичным ключом. Поле с ссылками на Id других строк называется внешним ключом(стр 144).
Бд которая не содержит повторяющейся информации называется нормальной. Процесс преобразование бд с дубликатами в бд без них называется нормализацией.

SQL

- _Structured Query Language_ -  «язык структурированных запросов»
SQL запрос  - это команда, сообщающая , какие данные должны быть получены:

SELECT <field name> [, <field name>,<field name>, ...]
FROM <table name>
WHERE <condition>;

Элементы идущие после Select - это поля которые нужно получить. Чтобы получить все поля в таблице : Select * . Базе данных может быть несколько таблиц, поэтому From уточняет какую таблицу мы запрашиваем. После команды Where вы устанавливаете  критерий отбора строк. Для перечисления многочисленных условий можно использовать логику.  Оператор Order _by  сортирует результаты по указанному полю(полям), а Group_By - поможет выполнить группировку  и получить агегированные результаты для групп. Например, при наличии таблицы  customers с полями country и age мы можем получить запрос:

SELECT country, AVG(age)
From customers
Group By country
Order By country;
 ОН вернет сортированный список стран, где проживают клиенты , вместе со средним возрастом клиентов по каждой стане.SQL предоставит и другие агрегатные функции. Например , замените AGE(age) на MAX(age), и мы получим возраст самого старого клиента в каждой стране.

Иногда бывает нужно изучить информацию из строки и строк ,с которыми она связана. Представьте,  что у нас есть таблица с заказами и таблица  с клиентами. Таблица orders имеет внешний ключ для ссылки на клиентов. Чтобы найти клиентов сделавшие дорогие заказы , придется выбрать данные из обоих таблиц. Но нам не нужно запрашивать их по отдельности и сопоставлять записи самостоятельно. Для этого в SQL есть отдельная  команда.

SELECT DISTINCT customers.name, customers.phonme
FROM customers
JOIN orders ON orders.customer = customers.id
WHERE orders.amount > 100.00;

Этот запрос вернёт имена и тел номера клиентов, сдел заказы более 100$. Команда SELECT DISTINCT заставляет вернуть СУБД вернуть каждого клиента только  1 раз. JOIN позволяет делать очень гибкие запросы(https://www.edureka.co/blog/sql-joins-types). Но соединения обходятся дорого. Базе придется рассмотреть все сочетания строк из таблиц, которые вы объеденяем в своём запросе. Для очень больших таблиц соединения становятся невыполнимыми. Оператор JOIN - самый мощный инструмент и одновременно главная слабость реляционных баз данных.

Индексация 

Чтобы от первичного ключа таблицы была польза, нужно быстро получить запись по ID. Для этого СУБД строит вспомогательный индекс, содержащий id строк, и соответ-е им адреса в памяти(стр 148). По сути , индекс - это сбалансированное двоичное древо поиска. Каждая строка в таблице соответствует узлу в дереве.

Ключи узлов - это значения в индексируемом поле.  Чтобы найти запись с заданным значением, мы ищем его в дереве. Найдя узел, мы получаем адрес, который он хранит, и используем его для выборки записи. Поиск по двоичному дереву имеет сложность 0(logn), по этому нахождение записей в больших таблицах выполняется быстро.

Обычно СУБД создает индекс для каждого первичного ключа в базе данных. Но если часто приходится искать записи по другим полям (например, искать клиентов по именам), можно поручить субд создать для них  дополнительные индексы.

Ограничения уникальности:: 
Индексы часто создаются автоматически для полей, которые имеют ограничение уникальности. При новой вставке новой строки СУБД должна обследовать всю таблицу, что бы удостовериться, что ни одно ограничение  уникальности не  нарушено. Не будь индекса, такая проверка означала бы, что нужно свериться со всеми строками в таблице. При помощи индекса мы можем быстро выполнить поиск и, например, обнаружить, что значение, которое мы пытаемся вставить, уже присутствует. Индексация полей, имеющих ограничение уникальности, необходима для быстрой вставки элементов.

Сортировка::
Индексы помогают выбирать строки в порядке сортировки по индексированным полям.  Пример, если имеется индекс для поля names, мы можем получить строки, отсортированные по имени, без дополнительных вычислений. Если применить команду ORDER BY к полю без индекса, СУБД придется отсортировать данные в памяти, прежде чем выполнить запрос. Многие СУБД  могут даже отказаться выполнять запрос, требующий произвести сортировку по неиндексированному полю, если в работу будет вовлечено слишком много строк.

Когда требуется сортировка по двум полям, используется комбинированные, или объединенные индексы. Они индексируют многочисленные поля и не способны помочь  искать элементы быстрее, зато позволяют легко получать данные, отсортированные по нескольким полям.

Производительность::
Почему нету индексов  для всех полей в каждой таблице?
Если индексов много, то обновление, вставка или удаление строк могут стать в вычислительном плане дорогостоящими операциями. Более того, индексы занимают определенное  дисковое пространство. 

Мы должны следить за тем, как наше приложение использует бд. СУБД обычно поставляются вместе с инструментами, которые помогают это делать. Они  могут "объяснять"  запросы, сообщая, какие индексы  использовались, а также сколько строк необходимо было последовательно  просканировать, чтобы выполнять запрос.  Если ваши запросы тратят впустую слишком много времени, последовательно сканируя данные в некоем поле, то добавьте для этого поля индекс и посмотрите, будет ли польза. Например, если мы часто ищем в бд людей конкретного возраста, то определение индекса для поля age позволит субд сразу отбирать строки, соответствующие конкретному возрасту. Мы сэкономим время, избежав последовательного просмотра базы данных с дальнейшей фильтрацией строк,  не соответствующих требуемому возрасту.

Чтобы повысить производительность бд  мы должны знать, какие индексы стоит сохранить, а какие отбросить. Если бд обычно используется в качестве чтения , а обновляется редко, то имеет смысл создать больше индексов. Плохая индексация  - главная причина замедлений в ком системах.  Небрежные системные администраторы зачастую не задаются вопросом, как выполняются типичные запросы - они просто индексируют произвольные поля, которые, по их мнению, будут способствовать производительности. Этого не стоит делать!  Воспользуйтесь "объясняющими инструментами", чтобы проверить свои запросы и создать индексы только там, где они нужны. 

ТРАНЗАКЦИИ 

Представим, что скрытный швейцарский банк не ведет учета денежных переводов: его бд  просто хранит баланс счетов.
Пример: Перевод денег внутри банка. Две операции выполнены внутри  1 бд - вычесть из 1 баланса и прибавить к другому.

Сервер Бд обычно позволяет многочисленным клиентам  читать и записывать данные одновременно - исполнение операций   в последовательном режиме сделало бы субд медленной. Но есть Нюанс если кто то запросит общий баланс  всех счетов после регистрации вычитания, но до соответствующего добавления, то какая то сумма будет отсутствовать.

Нам нужны способы, которыми СУБД  выполнила бы  все изменения входящие в многосоставную операцию, либо сохраняла данные неизменными. Для этого используются транзакции. Транзакция - список операций, которые должны быть выполнены атомарно(Атомарные операции выполняются одноэтапно: они не могут быть выполнены наполовину).

Выполнение многосоставных обновлений без транзакций рано или поздно создаст беспорядочные, непредсказуемые  и трудные в обнаружении противоречия в ваших данных.

								Нереляционная модель:

Нереляционная модель не использует табличные связи. Она почти никогда не требует объединять информацию из нескольких записей. поскольку нереляционные СУБД используют языки запросов, отличные от SQL, они также называются базами данных NoSQL.

Документальные хранилища.

Наиболее известным типом NoSQL являются документальные хранилища. В них записи хранятся в том виде? в котором они необходимы приложению. Сравнение табличный и документальный способ хранения  постов в блоге(стр 153).

Нереляционная модель предполагает возможность дублирования информации при необходимости. Однако, дублированные данные сложно своевременно обновлять и поддерживать их непротиворечивость. С другой стороны, группируя соответствующие данные, документальное хранилище может предложить Большую гибкость: 
	* нам не нужно соединять строки
	* можно обойтись без фиксированных схем
	* каждая запись может иметь собственное сочетание полей.

В док хранилищах вообще нет таблиц и строк. Вместо них есть записи, называемые документами. Связанные между собой документы группируются в коллекцию.

Документы имеют поле первичного ключа, поэтому их можно связать друг с другом. но операции JOIN в докум хранилищах неэффективны. Иногда они даже невозможны,  том случае нам придется следить за связями док самостоятельно.  И то и другое плохо - еслир доки имеют общие данные, их придется дублировать.

Как и рел бд, бд NoSQL создают индексы полей с первичным ключом. Также можно определять дополнительные индексы для полей, которые часто запрашиваются или сортируются.

Хранилища "Ключ - значение":
 - это простейшая форма организованного хранения данных. В основном используется для  кэширования. Например, когда некто запрашивает опр веб табл на сервере,  тот дожен выбрать соот ей данне из бд и исп их для  конструирования HTML - разметки, которую увидет юзер . В сайтах с выс посещаемостью, где случаются тысячи паралел доступов, делать это становиться невозможным.

Для решения проблемы  мы используем хранилище "ключ - значение" как механ кэширования.  Ключом является треб URL- адрес, значением - HTML разметка соот веб стр. В след раз, когда кто то попросит тот же URL , готовый код HTML  просто будет извлечен из хранилища "ключ - значение" черех ключ -адрес.

Если нам приходится раз за разом выполнять медленную операцию, всегда можно придти к одному и тому же результату, расмотрим возможность его кэширования.  Нам не обяз  использовать хран  "ключ - значение", кэш может содержаться и в бд другого типа. Однако когда кэш запрашивается очень часто, система хранилищ данных типа "ключ - значение" - лучший вариант.

Графовые бд:

В графовой бд записи хранятся в виде вершин, а связи в виде ребра. Вершины не привязаны к фиксированной схеме и могут содержать данные в разном формате. Граф структура  делает эффективной  работу  с записями в соответствии с их связями.(стр 155).

Это самый гибкий тип бд. Избавившись от таблиц и коллекций, мы можем хранить сетевые данные интуитивно понятным способом.

Если наши данные похожи на сеть нужно использовать графовые бд. Этот тип бд полезен, когда между компонентами много важных связей. Графовые бд также позволяют  выполнять различные типы граф-орентированных запросов. Например, если мы храним данные об общ транспорте в графе, можно прямо запросить лучший маршрут между 2мя остановками в одну сторону туда и обратно.

Большие данные.

BIG DATA описывает ситуации обработки данных, которые чрезвычайно сложны с точки зрения объема, скорости и разнообразия (5 V). Объем больших данных - это например обработка тысячи терабайт информации в  случае с БАК. Скорость применительно к биг данным означает что мы должны сохранять миллион записей в секунду без задержек или быстро выполнять миллиарды запросов на чтение. Разнообразие означает, что данные не имеют строгой структуры, и потому становятся очень трудно с ними справиться, используя традиционные реляционные бд. 

Каждый раз, когда нам понадобятся искать нестандартный подход к управлению  данными по причине их объёма, скорости или разнообразия, мы можем смело сказать, что имеем дело с биг данными.  Для выполнения некоторых  современных научных экспериментов  уже проводят исследования в области мегаданных, предполагающей хранение и анализ миллионов терабайт информации.

Биг данные часто связаны с нер-нными бд из-за повышенной гибкости. Многие типы приложений, работающих с биг данными, практически невозможно реализовать при помощи реляционных баз данных. 

SQL против NoSQL:

Рел-нные бд орентиров-нные на данные: они максимизируют структурирование данных и устраняют их дублирование независимо от того , в каком виде те требуются. Нер-онные БД, напротив, ориентированы на применение они облегчают доступ к данным и их использование  в соответствии с нашими потребностями.

Базы NoSQL позволяют быстро и эфф-вно сохранять крупные, изменчивые и неструктурированные данные. Не беспокоясь о фиксированных схемах и миграциях схемы, мы можем разрабатывать свои решения гораздо быстрее. Нер-нные бд естественней и проще.

Распределённая модель:
Есть несколько ситуаций, в которых для поддержания бд должен работать не один комп, а несколько, действующих координированно.
	* Бд объемом в несколько сотен террабайт.
	* СУБД обрабатывающий несколько тысяч одновременных запросов в секунду.
	* Жизненно важные бд, например те кто регистрируют высоту и скорость самолета, полагаться на одиночный компьютер слишком рискованно.

Для таких ситуаций сущ СУБД, способные работать на нескольких скоординированных компьютерах, образующие распределенные бд. 

Репликация с 1 ведущим (стр159 рис):

1 компьютер является ведущим и получает все запросы к бд. Он подключен к нескольким другим, ведомым компьютерам. Каждый из них содержит реплику, или копию, бд. Когда ведущий комп получает запросы на запись, он направляет их ведомым, обеспечивая их синхронизацию.

При такой организации вед комп способен обслужить больше запросов на чтение, потому что может делегировать их ведомым компьютерам. Система становится надежнее: если основной комп выключается, ведомые машины автоматически координируются и выбирают новый ведущий комп. Благодаря этому система не прекращает свою работу.


Репликация с много-нными ведущими:

Если наша СУБД должна обрабатывать большое кол-во одновременных запросов на запись, то один-единственный ведущий комп не справится с этой задачей.  В таком случае все компы в кластере становятся ведущим. Для равного рас-деления входящих запросов на чтение и запись между машинами используется балансировщик нагрузки(стр 160 рис).

Каждый комп подключен ко всем остальным, находящимся в кластере. Они делят запросы на запись между собой, в результате чегго все остаются синхронизированными. Каждый из них имеет копию всей бд.

Фрагментирование:

Если бд получает много запросов на запись с большими объемами данных, бывает чрезвычайно трудно синхронизировать ее везде в кластере. Некоторые компы могут не иметь достаточного пространства для размещения всех данных полностью. Одно из решений состоит в том, чтобы поделить базу данных между компьютерами. Поскольку каждый из них владеет лишь её частью, маршрутизатор направляет запросы соответствующей машине.(стр 161 6.10).

Такая конфи-ия способа обрабатывать многочисленные запросы на чтение и запись в случае с очень большими базами данных. Но с ней возможна  проблема: если машина в кластере выходит из строя, фрагмент данных, за который она отвечала, становится недоступен. Для снижения риска фрагментирование можно использовать в сочетании с репликацией.(стр 161 6.11)   

В таком случае каждый фрагмент выполняется кластером "ведущий- ведомый". Если один из главных серверов во фрагменте отключается от сети, ведомое устройство автоматически занимает его место - это гарантирует, что система не развалится и не потеряет данные.

Непротиворечивость данных:

 Обновления в распр-нных бд с репликацией, выполняемые на одной машине, не распр-тся немедленно по всем копиям. Проходит некоторое время, пока все компы в кластере синхр-уются. Это может нарушить непротиворечивость ваших данных.

Пример:
	Мы продаём билеты в кино. Трафик слишком большой, поэтому бд распределила на 2 сервере. Элис приобретает билет на сервере А. Боб на сервере Б и видит тот же самый свободный билет. Прежде чем инфор-ция  о покупке дойдет до сервера Б, Боб тоже заплатит за этот билет. Теперь два сервера имеют противоречивость в данных. Чтобы исправить ситуацию, вам придется отменить одну из продаж.

Системы бд часто содержат инстр-менты для снижения противоречивых данных. Например, где-то вам позволяют делать запросы, которые обеспечивают соблюдение непротиворечивости данных по всему кластеру. Однако это уменьшает произ-тельность СУБД.  В особенности сказанное касается транзакций: они могут вызывать серьезные проблемы  произ-тельности в распр-ленных бд, поскольку вынуждают выполнять координацию всех машин в кластере с блокировкой потенциально больших объемов  информации.

Есть компромисс решение между непротиворечивостью и производительностью. Если наши запросы к бд не требуют соблюдения строгой непротиворечивости данных, то говорят, что они работают в условиях потенциальной противоречивости.  Данные гарантированно будут непротиворечивыми в конечном счете - то есть через какое -то время. То есть это означает, что некоторые запросы на чтение могут вернуть устаревшую информацию. 

Во многих случаях работа с  потенциальной непротиворечивостью не вызывает особых проблем.  Пример, ничего страшного , если на странице нашего продукта 284 отзыва вместо 285  потому что 1 был сделан только  что.






