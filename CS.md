 Глава 6 Базы данных :
Глубинный анализ данных  - процесс извлечения информации из имеющихся массивов информации.

 
Реляционная модель.
Помогает избежать дублирования информации  и противоречий.
Большой недостаток  Рел модели - все записи  - строки , и СУБд не примет новою строку, если та нарушает схему таблицы.

Отношения.

Чтобы избежать трудностей повторений, реляционная модель разбивает данные на разные таблицы. Например, разделим наши данные о счетах-фактурах на две таблицы - "Заказы" и "Клиенты"- и сделаем так, чтобы каждая строка в первой таблице ссылалась на строку во второй ( стр 143)
За счет связывания между собой данных из различных таблиц один клиент может быть частью многих заказов, а дублирования при этом не случиться. Для поддержки связей каждая таблица имеет специальное идентификационное поле, или ID. Мы используем значения Id для ссылки на конкретную строку в таблице. Эти значения должны быть уникальными. Поле Id таблицы также называется её  первичным ключом. Поле с ссылками на Id других строк называется внешним ключом(стр 144).
Бд которая не содержит повторяющейся информации называется нормальной. Процесс преобразование бд с дубликатами в бд без них называется нормализацией.

SQL

- _Structured Query Language_ -  «язык структурированных запросов»
SQL запрос  - это команда, сообщающая , какие данные должны быть получены:

SELECT <field name> [, <field name>,<field name>, ...]
FROM <table name>
WHERE <condition>;

Элементы идущие после Select - это поля которые нужно получить. Чтобы получить все поля в таблице : Select * . Базе данных может быть несколько таблиц, поэтому From уточняет какую таблицу мы запрашиваем. После команды Where вы устанавливаете  критерий отбора строк. Для перечисления многочисленных условий можно использовать логику.  Оператор Order _by  сортирует результаты по указанному полю(полям), а Group_By - поможет выполнить группировку  и получить агегированные результаты для групп. Например, при наличии таблицы  customers с полями country и age мы можем получить запрос:

SELECT country, AVG(age)
From customers
Group By country
Order By country;
 ОН вернет сортированный список стран, где проживают клиенты , вместе со средним возрастом клиентов по каждой стане.SQL предоставит и другие агрегатные функции. Например , замените AGE(age) на MAX(age), и мы получим возраст самого старого клиента в каждой стране.

Иногда бывает нужно изучить информацию из строки и строк ,с которыми она связана. Представьте,  что у нас есть таблица с заказами и таблица  с клиентами. Таблица orders имеет внешний ключ для ссылки на клиентов. Чтобы найти клиентов сделавшие дорогие заказы , придется выбрать данные из обоих таблиц. Но нам не нужно запрашивать их по отдельности и сопоставлять записи самостоятельно. Для этого в SQL есть отдельная  команда.

SELECT DISTINCT customers.name, customers.phonme
FROM customers
JOIN orders ON orders.customer = customers.id
WHERE orders.amount > 100.00;

Этот запрос вернёт имена и тел номера клиентов, сдел заказы более 100$. Команда SELECT DISTINCT заставляет вернуть СУБД вернуть каждого клиента только  1 раз. JOIN позволяет делать очень гибкие запросы(https://www.edureka.co/blog/sql-joins-types). Но соединения обходятся дорого. Базе придется рассмотреть все сочетания строк из таблиц, которые вы объеденяем в своём запросе. Для очень больших таблиц соединения становятся невыполнимыми. Оператор JOIN - самый мощный инструмент и одновременно главная слабость реляционных баз данных.

Индексация 

Чтобы от первичного ключа таблицы была польза, нужно быстро получить запись по ID. Для этого СУБД строит вспомогательный индекс, содержащий id строк, и соответ-е им адреса в памяти(стр 148). По сути , индекс - это сбалансированное двоичное древо поиска. Каждая строка в таблице соответствует узлу в дереве.

Ключи узлов - это значения в индексируемом поле.  Чтобы найти запись с заданным значением, мы ищем его в дереве. Найдя узел, мы получаем адрес, который он хранит, и используем его для выборки записи. Поиск по двоичному дереву имеет сложность 0(logn), по этому нахождение записей в больших таблицах выполняется быстро.

Обычно СУБД создает индекс для каждого первичного ключа в базе данных. Но если часто приходится искать записи по другим полям (например, искать клиентов по именам), можно поручить субд создать для них  дополнительные индексы.

Ограничения уникальности:: 
Индексы часто создаются автоматически для полей, которые имеют ограничение уникальности. При новой вставке новой строки СУБД должна обследовать всю таблицу, что бы удостовериться, что ни одно ограничение  уникальности не  нарушено. Не будь индекса, такая проверка означала бы, что нужно свериться со всеми строками в таблице. При помощи индекса мы можем быстро выполнить поиск и, например, обнаружить, что значение, которое мы пытаемся вставить, уже присутствует. Индексация полей, имеющих ограничение уникальности, необходима для быстрой вставки элементов.

Сортировка::
Индексы помогают выбирать строки в порядке сортировки по индексированным полям.  Пример, если имеется индекс для поля names, мы можем получить строки, отсортированные по имени, без дополнительных вычислений. Если применить команду ORDER BY к полю без индекса, СУБД придется отсортировать данные в памяти, прежде чем выполнить запрос. Многие СУБД  могут даже отказаться выполнять запрос, требующий произвести сортировку по неиндексированному полю, если в работу будет вовлечено слишком много строк.

Когда требуется сортировка по двум полям, используется комбинированные, или объединенные индексы. Они индексируют многочисленные поля и не способны помочь  искать элементы быстрее, зато позволяют легко получать данные, отсортированные по нескольким полям.

Производительность::
Почему нету индексов  для всех полей в каждой таблице?
Если индексов много, то обновление, вставка или удаление строк могут стать в вычислительном плане дорогостоящими операциями. Более того, индексы занимают определенное  дисковое пространство. 

Мы должны следить за тем, как наше приложение использует бд. СУБД обычно поставляются вместе с инструментами, которые помогают это делать. Они  могут "объяснять"  запросы, сообщая, какие индексы  использовались, а также сколько строк необходимо было последовательно  просканировать, чтобы выполнять запрос.  Если ваши запросы тратят впустую слишком много времени, последовательно сканируя данные в некоем поле, то добавьте для этого поля индекс и посмотрите, будет ли польза. Например, если мы часто ищем в бд людей конкретного возраста, то определение индекса для поля age позволит субд сразу отбирать строки, соответствующие конкретному возрасту. Мы сэкономим время, избежав последовательного просмотра базы данных с дальнейшей фильтрацией строк,  не соответствующих требуемому возрасту.

Чтобы повысить производительность бд  мы должны знать, какие индексы стоит сохранить, а какие отбросить. Если бд обычно используется в качестве чтения , а обновляется редко, то имеет смысл создать больше индексов. Плохая индексация  - главная причина замедлений в ком системах.  Небрежные системные администраторы зачастую не задаются вопросом, как выполняются типичные запросы - они просто индексируют произвольные поля, которые, по их мнению, будут способствовать производительности. Этого не стоит делать!  Воспользуйтесь "объясняющими инструментами", чтобы проверить свои запросы и создать индексы только там, где они нужны. 

ТРАНЗАКЦИИ 

Представим, что скрытный швейцарский банк не ведет учета денежных переводов: его бд  просто хранит баланс счетов.
 
