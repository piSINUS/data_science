Глава 6 Базы данных :
Глубинный анализ данных  - процесс извлечения информации из имеющихся массивов информации.

 
Реляционная модель.
Помогает избежать дублирования информации  и противоречий.
Большой недостаток  Рел модели - все записи  - строки , и СУБд не примет новою строку, если та нарушает схему таблицы.

Отношения.

Чтобы избежать трудностей повторений, реляционная модель разбивает данные на разные таблицы. Например, разделим наши данные о счетах-фактурах на две таблицы - "Заказы" и "Клиенты"- и сделаем так, чтобы каждая строка в первой таблице ссылалась на строку во второй ( стр 143)
За счет связывания между собой данных из различных таблиц один клиент может быть частью многих заказов, а дублирования при этом не случиться. Для поддержки связей каждая таблица имеет специальное идентификационное поле, или ID. Мы используем значения Id для ссылки на конкретную строку в таблице. Эти значения должны быть уникальными. Поле Id таблицы также называется её  первичным ключом. Поле с ссылками на Id других строк называется внешним ключом(стр 144).
Бд которая не содержит повторяющейся информации называется нормальной. Процесс преобразование бд с дубликатами в бд без них называется нормализацией.

SQL

- _Structured Query Language_ -  «язык структурированных запросов»
SQL запрос  - это команда, сообщающая , какие данные должны быть получены:

SELECT <field name> [, <field name>,<field name>, ...]
FROM <table name>
WHERE <condition>;

Элементы идущие после Select - это поля которые нужно получить. Чтобы получить все поля в таблице : Select * . Базе данных может быть несколько таблиц, поэтому From уточняет какую таблицу мы запрашиваем. После команды Where вы устанавливаете  критерий отбора строк. Для перечисления многочисленных условий можно использовать логику.  Оператор Order _by  сортирует результаты по указанному полю(полям), а Group_By - поможет выполнить группировку  и получить агегированные результаты для групп. Например, при наличии таблицы  customers с полями country и age мы можем получить запрос:

SELECT country, AVG(age)
From customers
Group By country
Order By country;
 ОН вернет сортированный список стран, где проживают клиенты , вместе со средним возрастом клиентов по каждой стане.SQL предоставит и другие агрегатные функции. Например , замените AGE(age) на MAX(age), и мы получим возраст самого старого клиента в каждой стране.

Иногда бывает нужно изучить информацию из строки и строк ,с которыми она связана. Представьте,  что у нас есть таблица с заказами и таблица  с клиентами. Таблица orders имеет внешний ключ для ссылки на клиентов. Чтобы найти клиентов сделавшие дорогие заказы , придется выбрать данные из обоих таблиц. Но нам не нужно запрашивать их по отдельности и сопоставлять записи самостоятельно. Для этого в SQL есть отдельная  команда.

SELECT DISTINCT customers.name, customers.phonme
FROM customers
JOIN orders ON orders.customer = customers.id
WHERE orders.amount > 100.00;

Этот запрос вернёт имена и тел номера клиентов, сдел заказы более 100$. Команда SELECT DISTINCT заставляет вернуть СУБД вернуть каждого клиента только  1 раз. JOIN позволяет делать очень гибкие запросы(https://www.edureka.co/blog/sql-joins-types). Но соединения обходятся дорого. Базе придется рассмотреть все сочетания строк из таблиц, которые вы объеденяем в своём запросе. Для очень больших таблиц соединения становятся невыполнимыми. Оператор JOIN - самый мощный инструмент и одновременно главная слабость реляционных баз данных.